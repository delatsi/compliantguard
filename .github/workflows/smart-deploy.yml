name: Smart Deployment (Idempotent)

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ develop ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment of both backend and frontend'
        type: boolean
        default: false
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

permissions:
  contents: read
  security-events: write
  actions: read

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  # Detect what changed to determine deployment strategy
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      backend_changed: ${{ steps.changes.outputs.backend }}
      frontend_changed: ${{ steps.changes.outputs.frontend }}
      infrastructure_changed: ${{ steps.changes.outputs.infrastructure }}
      environment: ${{ steps.env.outputs.environment }}
      deployment_strategy: ${{ steps.strategy.outputs.strategy }}
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Need at least 2 commits to compare

    - name: Detect changed files
      uses: dorny/paths-filter@v3
      id: changes
      with:
        filters: |
          backend:
            - 'backend/**'
            - 'template.yaml'
            - 'samconfig.toml'
            - 'requirements.txt'
            - 'version.json'
          frontend:
            - 'frontend/**'
            - 'frontend-template.yaml'
            - 'version.json'
          infrastructure:
            - 'template.yaml'
            - 'frontend-template.yaml'
            - 'samconfig.toml'
            - '.github/workflows/**'
          docs:
            - 'docs/**'
            - '*.md'

    - name: Determine environment
      id: env
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          ENVIRONMENT="staging"
        elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
          ENVIRONMENT="dev"
        else
          ENVIRONMENT="dev"  # PR builds
        fi
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "ðŸŒ Target environment: $ENVIRONMENT"

    - name: Determine deployment strategy
      id: strategy
      run: |
        BACKEND_CHANGED="${{ steps.changes.outputs.backend }}"
        FRONTEND_CHANGED="${{ steps.changes.outputs.frontend }}"
        FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
        
        if [[ "$FORCE_DEPLOY" == "true" ]]; then
          STRATEGY="full"
          echo "ðŸš€ Force deployment requested - deploying both backend and frontend"
        elif [[ "$BACKEND_CHANGED" == "true" && "$FRONTEND_CHANGED" == "true" ]]; then
          STRATEGY="full"
          echo "ðŸ”„ Both backend and frontend changed - full deployment"
        elif [[ "$BACKEND_CHANGED" == "true" ]]; then
          STRATEGY="backend-only"
          echo "âš¡ Only backend changed - backend deployment only"
        elif [[ "$FRONTEND_CHANGED" == "true" ]]; then
          STRATEGY="frontend-only"
          echo "ðŸŽ¨ Only frontend changed - frontend deployment only"
        else
          STRATEGY="none"
          echo "ðŸ“ No deployment needed - only docs or other files changed"
        fi
        
        echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT
        echo "Backend changed: $BACKEND_CHANGED"
        echo "Frontend changed: $FRONTEND_CHANGED"

  # Run tests only for changed components
  test-backend:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.backend_changed == 'true' || needs.detect-changes.outputs.deployment_strategy == 'full'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio ruff

    - name: Run linting and formatting checks
      run: |
        cd backend
        echo "ðŸš€ Running ruff check (linting)..."
        ruff check . --output-format=github
        echo "ðŸŽ¨ Running ruff format (formatting)..."
        ruff format . --check

    - name: Run tests with coverage
      run: |
        cd backend
        if [ -d "tests" ]; then
          echo "ðŸ§ª Running backend tests..."
          pytest tests/ -v --cov=. --cov-report=xml --cov-report=term
        else
          echo "âš ï¸ No tests directory found, creating placeholder"
          mkdir -p tests
          echo "# Placeholder test file" > tests/__init__.py
          touch coverage.xml
        fi

    - name: Upload coverage
      uses: codecov/codecov-action@v4
      if: env.CODECOV_TOKEN != ''
      with:
        file: ./backend/coverage.xml
        flags: backend
        name: backend-coverage
      env:
        CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  test-frontend:
    needs: detect-changes
    runs-on: ubuntu-latest
    if: needs.detect-changes.outputs.frontend_changed == 'true' || needs.detect-changes.outputs.deployment_strategy == 'full'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Run linting
      run: |
        cd frontend
        echo "ðŸ” Running frontend linting..."
        npm run lint

    - name: Run tests
      run: |
        cd frontend
        echo "ðŸ§ª Running frontend tests..."
        if npm run | grep -q "test:unit"; then
          npm run test:unit
        elif npm run | grep -q "test"; then
          npm test
        else
          echo "âš ï¸ No tests configured, skipping"
        fi

    - name: Build frontend (test build)
      run: |
        cd frontend
        echo "ðŸ—ï¸ Testing frontend build..."
        npm run build

  # Security scan (always run for comprehensive security)
  security-scan:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'HIGH,CRITICAL'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

    - name: Check for secrets
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        extra_args: --only-verified

  # Deploy backend only if needed (idempotent)
  deploy-backend:
    needs: [detect-changes, test-backend, security-scan]
    runs-on: ubuntu-latest
    if: always() && !failure() && (needs.detect-changes.outputs.backend_changed == 'true' || needs.detect-changes.outputs.deployment_strategy == 'full') && github.event_name != 'pull_request'
    environment: ${{ needs.detect-changes.outputs.environment }}
    
    outputs:
      api_url: ${{ steps.get-api-url.outputs.api_url }}
      stack_name: ${{ steps.deploy.outputs.stack_name }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Set up SAM CLI
      uses: aws-actions/setup-sam@v2
      with:
        use-installer: true

    - name: Set environment-specific AWS credentials
      id: set-creds
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        echo "ðŸ”‘ Setting AWS credentials for environment: $ENVIRONMENT"
        
        case "$ENVIRONMENT" in
          "dev")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_DEV secret is not configured"
              exit 1
            fi
            echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
            echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
            echo "âœ… Using DEV AWS credentials"
            ;;
          "staging")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_STAGING secret is not configured"
              echo "ðŸ”„ Falling back to DEV credentials for staging deployment"
              echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
              echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
              echo "âš ï¸  Using DEV AWS credentials for staging (staging secrets not configured)"
            else
              echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" >> $GITHUB_OUTPUT
              echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" >> $GITHUB_OUTPUT
              echo "âœ… Using STAGING AWS credentials"
            fi
            ;;
          "prod")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_PROD secret is not configured"
              exit 1
            fi
            echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_OUTPUT
            echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_OUTPUT
            echo "âœ… Using PROD AWS credentials"
            ;;
          *)
            echo "âŒ Unknown environment: $ENVIRONMENT"
            exit 1
            ;;
        esac

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ steps.set-creds.outputs.access-key-id }}
        aws-secret-access-key: ${{ steps.set-creds.outputs.secret-access-key }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Cache SAM dependencies
      uses: actions/cache@v4
      with:
        path: |
          .aws-sam
          backend/.aws-sam
        key: ${{ runner.os }}-sam-${{ hashFiles('**/template.yaml', '**/samconfig.toml') }}
        restore-keys: |
          ${{ runner.os }}-sam-

    - name: Build SAM application
      run: |
        echo "ðŸ—ï¸ Building SAM application for ${{ needs.detect-changes.outputs.environment }}..."
        sam build --config-env ${{ needs.detect-changes.outputs.environment }}

    - name: Deploy with stable stack name
      id: deploy
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        STACK_NAME="themisguard-api-${ENVIRONMENT}"
        
        echo "ðŸš€ Deploying backend to $ENVIRONMENT environment..."
        echo "ðŸ“‹ Stack name: $STACK_NAME (stable, no timestamps)"
        
        # Check current stack status
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        echo "ðŸ“Š Current stack status: $STACK_STATUS"
        
        # Deploy using stable stack name (idempotent)
        GOOGLE_CLIENT_ID="${{ needs.detect-changes.outputs.environment == 'dev' && secrets.GOOGLE_CLIENT_ID_DEV || needs.detect-changes.outputs.environment == 'staging' && secrets.GOOGLE_CLIENT_ID_STAGING || secrets.GOOGLE_CLIENT_ID_PROD }}"
        
        # Build parameter overrides - only include GoogleClientId if it's not empty
        DEPLOYMENT_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        PARAM_OVERRIDES="Environment=$ENVIRONMENT ProjectName=themisguard Version=${{ github.sha }} Branch=${{ github.ref_name }}"
        
        # Set environment variables for Lambda function
        export GITHUB_SHA="${{ github.sha }}"
        export DEPLOYMENT_TIME="$DEPLOYMENT_TIME"
        if [[ -n "$GOOGLE_CLIENT_ID" ]]; then
          PARAM_OVERRIDES="$PARAM_OVERRIDES GoogleClientId=$GOOGLE_CLIENT_ID"
        fi
        
        sam deploy \
          --config-env "$ENVIRONMENT" \
          --stack-name "$STACK_NAME" \
          --resolve-s3 \
          --no-confirm-changeset \
          --no-fail-on-empty-changeset \
          --parameter-overrides $PARAM_OVERRIDES
        
        echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
        echo "âœ… Backend deployment completed successfully"

    - name: Get API URL
      id: get-api-url
      run: |
        STACK_NAME="${{ steps.deploy.outputs.stack_name }}"
        
        # Wait a moment for stack outputs to be available
        sleep 10
        
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        if [[ -z "$API_URL" || "$API_URL" == "None" ]]; then
          echo "âš ï¸ Could not get API URL from stack, using default"
          API_URL="https://api-${{ needs.detect-changes.outputs.environment }}.example.com"
        fi
        
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "ðŸ”— API URL: $API_URL"

    - name: Run API health check
      run: |
        API_URL="${{ steps.get-api-url.outputs.api_url }}"
        echo "ðŸ¥ Running API health check..."
        
        # Wait for API to be ready
        sleep 30
        
        # Try health check with retry
        for i in {1..3}; do
          if curl -f -s "$API_URL/health" > /dev/null 2>&1; then
            echo "âœ… API health check passed"
            break
          else
            echo "â³ Health check attempt $i failed, retrying..."
            sleep 15
          fi
        done

  # Deploy frontend only if needed (idempotent)
  deploy-frontend:
    needs: [detect-changes, test-frontend, deploy-backend]
    runs-on: ubuntu-latest
    if: always() && !failure() && needs.detect-changes.outputs.deployment_strategy == 'full' && github.event_name != 'pull_request'
    environment: ${{ needs.detect-changes.outputs.environment }}
    
    outputs:
      frontend_url: ${{ steps.deploy-frontend.outputs.frontend_url }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Set environment-specific AWS credentials  
      id: set-creds
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        echo "ðŸ”‘ Setting AWS credentials for environment: $ENVIRONMENT"
        
        case "$ENVIRONMENT" in
          "dev")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_DEV secret is not configured"
              exit 1
            fi
            echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
            echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
            echo "âœ… Using DEV AWS credentials"
            ;;
          "staging")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_STAGING secret is not configured"
              echo "ðŸ”„ Falling back to DEV credentials for staging deployment"
              echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
              echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
              echo "âš ï¸  Using DEV AWS credentials for staging (staging secrets not configured)"
            else
              echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" >> $GITHUB_OUTPUT
              echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" >> $GITHUB_OUTPUT
              echo "âœ… Using STAGING AWS credentials"
            fi
            ;;
          "prod")
            if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" ]]; then
              echo "âŒ AWS_ACCESS_KEY_ID_PROD secret is not configured"
              exit 1
            fi
            echo "access-key-id=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_OUTPUT
            echo "secret-access-key=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_OUTPUT
            echo "âœ… Using PROD AWS credentials"
            ;;
          *)
            echo "âŒ Unknown environment: $ENVIRONMENT"
            exit 1
            ;;
        esac

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ steps.set-creds.outputs.access-key-id }}
        aws-secret-access-key: ${{ steps.set-creds.outputs.secret-access-key }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Deploy frontend infrastructure (idempotent)
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        STACK_NAME="compliantguard-frontend-${ENVIRONMENT}"
        
        echo "ðŸ—ï¸ Ensuring frontend infrastructure exists..."
        echo "ðŸ“‹ Stack name: $STACK_NAME (stable, no timestamps)"
        
        # Check if stack exists
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        echo "ðŸ“Š Frontend infrastructure status: $STACK_STATUS"
        
        if [[ "$STACK_STATUS" == "DOES_NOT_EXIST" ]]; then
          echo "ðŸ“¦ Creating frontend infrastructure..."
          aws cloudformation create-stack \
            --stack-name "$STACK_NAME" \
            --template-body file://frontend-minimal.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue="$ENVIRONMENT" \
            --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
            --tags \
              Key=Environment,Value="$ENVIRONMENT" \
              Key=Project,Value=CompliantGuard \
              Key=Component,Value=frontend \
              Key=Tier,Value="${{ needs.detect-changes.outputs.environment == 'prod' && 'production' || 'development' }}" \
              Key=Owner,Value=DevOps \
              Key=CostCenter,Value=Engineering \
              Key=ManagedBy,Value=GitHubActions
          
          echo "â³ Waiting for infrastructure creation..."
          aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME"
          echo "âœ… Frontend infrastructure created"
        elif [[ "$STACK_STATUS" =~ ^(CREATE_COMPLETE|UPDATE_COMPLETE)$ ]]; then
          echo "âœ… Frontend infrastructure already exists and is ready"
        elif [[ "$STACK_STATUS" == "ROLLBACK_COMPLETE" ]]; then
          echo "ðŸš¨ Stack is in ROLLBACK_COMPLETE state - previous creation failed"
          echo "ðŸ—‘ï¸ Deleting failed stack to allow recreation..."
          aws cloudformation delete-stack --stack-name "$STACK_NAME"
          echo "â³ Waiting for stack deletion..."
          aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME"
          echo "âœ… Failed stack deleted"
          
          echo "ðŸ“¦ Attempting to create fresh frontend infrastructure..."
          if aws cloudformation create-stack \
            --stack-name "$STACK_NAME" \
            --template-body file://frontend-minimal.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue="$ENVIRONMENT" \
            --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND \
            --tags \
              Key=Environment,Value="$ENVIRONMENT" \
              Key=Project,Value=CompliantGuard \
              Key=Component,Value=frontend \
              Key=Tier,Value="${{ needs.detect-changes.outputs.environment == 'prod' && 'production' || 'development' }}" \
              Key=Owner,Value=DevOps \
              Key=CostCenter,Value=Engineering \
              Key=ManagedBy,Value=GitHubActions; then
            echo "â³ Waiting for infrastructure creation..."
            if aws cloudformation wait stack-create-complete --stack-name "$STACK_NAME"; then
              echo "âœ… Frontend infrastructure created successfully"
            else
              echo "âŒ Stack creation failed again. Falling back to direct S3 bucket creation..."
              # Fallback: create bucket directly without CloudFormation
              BUCKET_NAME="compliantguard-frontend-fallback-${ENVIRONMENT}-$(date +%s)"
              echo "ðŸª£ Creating fallback S3 bucket: $BUCKET_NAME"
              if aws s3 mb "s3://$BUCKET_NAME" --region us-east-1; then
                aws s3 website "s3://$BUCKET_NAME" --index-document index.html --error-document index.html
                echo "FALLBACK_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
                echo "âœ… Fallback bucket created successfully: $BUCKET_NAME"
                echo "ðŸŽ¯ Infrastructure deployment completed using fallback method"
              else
                echo "âŒ Failed to create fallback S3 bucket. This is a critical failure."
                exit 1
              fi
            fi
          else
            echo "âŒ CloudFormation create-stack command failed. Using direct S3 approach..."
            # Immediate fallback: create bucket directly
            BUCKET_NAME="compliantguard-frontend-fallback-${ENVIRONMENT}-$(date +%s)"
            echo "ðŸª£ Creating fallback S3 bucket: $BUCKET_NAME"
            if aws s3 mb "s3://$BUCKET_NAME" --region us-east-1; then
              aws s3 website "s3://$BUCKET_NAME" --index-document index.html --error-document index.html
              echo "FALLBACK_BUCKET=$BUCKET_NAME" >> $GITHUB_ENV
              echo "âœ… Fallback bucket created successfully: $BUCKET_NAME"
              echo "ðŸŽ¯ Infrastructure deployment completed using fallback method"
            else
              echo "âŒ Failed to create fallback S3 bucket. This is a critical failure."
              exit 1
            fi
          fi
        else
          echo "âš ï¸ Infrastructure in unexpected state: $STACK_STATUS"
          echo "ðŸ”„ Attempting to update infrastructure..."
          aws cloudformation update-stack \
            --stack-name "$STACK_NAME" \
            --template-body file://frontend-minimal.yaml \
            --parameters \
              ParameterKey=Environment,ParameterValue="$ENVIRONMENT" \
            --capabilities CAPABILITY_IAM CAPABILITY_AUTO_EXPAND 2>/dev/null || echo "No updates needed"
        fi

    - name: Install dependencies and build
      run: |
        cd frontend
        echo "ðŸ“¦ Installing frontend dependencies..."
        echo "ðŸ” Environment debug - FALLBACK_BUCKET: ${FALLBACK_BUCKET:-'not set'}"
        npm ci

    - name: Build frontend with API URL
      run: |
        cd frontend
        
        # Get API URL from backend deployment or use default
        API_URL="${{ needs.deploy-backend.outputs.api_url }}"
        if [[ -z "$API_URL" || "$API_URL" == "None" ]]; then
          # Try to get from existing stack
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "themisguard-api-${{ needs.detect-changes.outputs.environment }}" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
            --output text 2>/dev/null || echo "")
          
          if [[ -z "$API_URL" ]]; then
            API_URL="https://api-${{ needs.detect-changes.outputs.environment }}.example.com"
            echo "âš ï¸ Using fallback API URL: $API_URL"
          fi
        fi
        
        echo "ðŸ”— Building with API URL: $API_URL"
        
        # Read version from version.json
        APP_VERSION=$(cat ../version.json | jq -r '.app_version // "1.2.0"')
        API_VERSION=$(cat ../version.json | jq -r '.api_version // "1.2.0"')
        BUILD_DATE=$(date -u +"%Y-%m-%d")
        
        echo "VITE_API_URL=$API_URL" > .env.production
        echo "VITE_ENVIRONMENT=${{ needs.detect-changes.outputs.environment }}" >> .env.production
        echo "VITE_VERSION=${{ github.sha }}" >> .env.production
        echo "VITE_APP_VERSION=$APP_VERSION" >> .env.production
        echo "VITE_API_VERSION=$API_VERSION" >> .env.production
        echo "VITE_BUILD_DATE=$BUILD_DATE" >> .env.production
        
        echo "ðŸ—ï¸ Building frontend..."
        npm run build

    - name: Deploy frontend to S3
      id: deploy-frontend
      run: |
        cd frontend
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        STACK_NAME="compliantguard-frontend-${ENVIRONMENT}"
        
        # Get S3 bucket from infrastructure stack with debugging
        echo "ðŸ” Checking stack outputs for bucket name..."
        
        # First check if stack exists and is in good state
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "DOES_NOT_EXIST")
        echo "ðŸ“Š Stack status: $STACK_STATUS"
        
        # Handle different stack states appropriately
        if [[ "$STACK_STATUS" == "ROLLBACK_COMPLETE" ]]; then
          echo "âš ï¸ Stack is in ROLLBACK_COMPLETE state, but infrastructure step should have handled this"
          echo "ðŸ” Checking if fallback bucket was created..."
          if [[ -n "${FALLBACK_BUCKET}" ]]; then
            echo "âœ… Found fallback bucket: ${FALLBACK_BUCKET}"
          else
            echo "âŒ No fallback bucket found. Infrastructure deployment may have failed."
            echo "ðŸ” Available environment variables:"
            env | grep -E "(BUCKET|FALLBACK)" || echo "No bucket-related environment variables found"
            exit 1
          fi
        elif [[ "$STACK_STATUS" != "CREATE_COMPLETE" && "$STACK_STATUS" != "UPDATE_COMPLETE" && "$STACK_STATUS" != "DOES_NOT_EXIST" ]]; then
          echo "âŒ Stack in unexpected state: $STACK_STATUS"
          exit 1
        fi
        
        # List all outputs for debugging
        echo "ðŸ“‹ Available stack outputs:"
        aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[].{Key:OutputKey,Value:OutputValue}' \
          --output table || echo "No outputs found"
        
        # Get bucket name - either from CloudFormation or fallback
        if [[ -n "${FALLBACK_BUCKET}" ]]; then
          BUCKET_NAME="${FALLBACK_BUCKET}"
          echo "ðŸ“¦ Using fallback bucket: $BUCKET_NAME"
        else
          # Get bucket name from CloudFormation stack
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`BucketName`].OutputValue' \
            --output text 2>/dev/null || echo "")
          
          if [[ -z "$BUCKET_NAME" || "$BUCKET_NAME" == "None" ]]; then
            echo "âŒ Could not get S3 bucket name from infrastructure stack"
            echo "ðŸ” This might be because:"
            echo "   - Stack outputs don't include 'BucketName'"
            echo "   - Stack is in wrong state: $STACK_STATUS"
            echo "   - Query syntax doesn't match output structure"
            exit 1
          fi
          echo "ðŸ“¦ Using CloudFormation bucket: $BUCKET_NAME"
        fi
        
        echo "ðŸ“¤ Deploying frontend to S3 bucket: $BUCKET_NAME"
        
        # Sync files with appropriate cache headers
        aws s3 sync dist/ "s3://$BUCKET_NAME/" --delete \
          --cache-control "public, max-age=31536000" \
          --exclude "*.html" \
          --exclude "*.js.map"
        
        # Set no-cache for HTML files
        aws s3 sync dist/ "s3://$BUCKET_NAME/" \
          --cache-control "no-cache, no-store, must-revalidate" \
          --include "*.html" \
          --content-type "text/html"
        
        # Get frontend URL
        FRONTEND_URL=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[?OutputKey==`WebsiteURL`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
        echo "âœ… Frontend deployed successfully"
        echo "ðŸŒ Frontend URL: $FRONTEND_URL"

    - name: Frontend deployment complete
      run: |
        echo "âœ… Frontend deployed successfully to S3 static hosting"

  # Deploy frontend only (when backend hasn't changed)
  deploy-frontend-only:
    needs: [detect-changes, test-frontend]
    runs-on: ubuntu-latest
    if: always() && !failure() && (needs.detect-changes.outputs.deployment_strategy == 'frontend-only' || (needs.detect-changes.outputs.frontend_changed == 'true' && needs.detect-changes.outputs.deployment_strategy != 'full')) && github.event_name != 'pull_request'
    environment: ${{ needs.detect-changes.outputs.environment }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ needs.detect-changes.outputs.environment == 'dev' && secrets.AWS_ACCESS_KEY_ID_DEV || needs.detect-changes.outputs.environment == 'staging' && secrets.AWS_ACCESS_KEY_ID_STAGING || secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ needs.detect-changes.outputs.environment == 'dev' && secrets.AWS_SECRET_ACCESS_KEY_DEV || needs.detect-changes.outputs.environment == 'staging' && secrets.AWS_SECRET_ACCESS_KEY_STAGING || secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get existing API URL
      id: get-api-url
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        
        # Get API URL from existing backend stack
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name "themisguard-api-${ENVIRONMENT}" \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        if [[ -z "$API_URL" || "$API_URL" == "None" ]]; then
          API_URL="https://api-${ENVIRONMENT}.example.com"
          echo "âš ï¸ Using fallback API URL: $API_URL"
        fi
        
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "ðŸ”— Using existing API URL: $API_URL"

    - name: Build and deploy frontend
      run: |
        cd frontend
        
        echo "ðŸ“¦ Installing dependencies..."
        npm ci
        
        echo "ðŸ—ï¸ Building frontend..."
        
        # Read version from version.json
        APP_VERSION=$(cat ../version.json | jq -r '.app_version // "1.2.0"')
        API_VERSION=$(cat ../version.json | jq -r '.api_version // "1.2.0"')
        BUILD_DATE=$(date -u +"%Y-%m-%d")
        
        echo "VITE_API_URL=${{ steps.get-api-url.outputs.api_url }}" > .env.production
        echo "VITE_ENVIRONMENT=${{ needs.detect-changes.outputs.environment }}" >> .env.production
        echo "VITE_VERSION=${{ github.sha }}" >> .env.production
        echo "VITE_APP_VERSION=$APP_VERSION" >> .env.production
        echo "VITE_API_VERSION=$API_VERSION" >> .env.production
        echo "VITE_BUILD_DATE=$BUILD_DATE" >> .env.production
        npm run build
        
        echo "ðŸ“¤ Deploying frontend..."
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        STACK_NAME="compliantguard-frontend-${ENVIRONMENT}"
        
        # Get S3 bucket with debugging
        echo "ðŸ” Retrieving bucket name from stack: $STACK_NAME"
        
        # List outputs for debugging
        echo "ðŸ“‹ Available outputs:"
        aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[].{Key:OutputKey,Value:OutputValue}' \
          --output table || echo "No outputs found"
        
        BUCKET_NAME=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[?OutputKey==`BucketName`].OutputValue' \
          --output text)
        
        if [[ -z "$BUCKET_NAME" || "$BUCKET_NAME" == "None" ]]; then
          echo "âŒ Could not retrieve bucket name from stack outputs"
          exit 1
        fi
        
        echo "ðŸ“¦ Using S3 bucket: $BUCKET_NAME"
        
        # Deploy to S3
        aws s3 sync dist/ "s3://$BUCKET_NAME/" --delete
        
        echo "âœ… Frontend deployed successfully to S3 static hosting"

  # Final smoke tests
  smoke-test:
    needs: [detect-changes, deploy-backend, deploy-frontend, deploy-frontend-only]
    runs-on: ubuntu-latest
    if: always() && !failure() && needs.detect-changes.outputs.deployment_strategy != 'none' && github.event_name != 'pull_request'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ needs.detect-changes.outputs.environment == 'dev' && secrets.AWS_ACCESS_KEY_ID_DEV || needs.detect-changes.outputs.environment == 'staging' && secrets.AWS_ACCESS_KEY_ID_STAGING || secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ needs.detect-changes.outputs.environment == 'dev' && secrets.AWS_SECRET_ACCESS_KEY_DEV || needs.detect-changes.outputs.environment == 'staging' && secrets.AWS_SECRET_ACCESS_KEY_STAGING || secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment URLs
      id: get-urls
      run: |
        ENVIRONMENT="${{ needs.detect-changes.outputs.environment }}"
        
        # Get API URL
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name "themisguard-api-${ENVIRONMENT}" \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayUrl`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        # Get Frontend URL  
        FRONTEND_URL=$(aws cloudformation describe-stacks \
          --stack-name "compliantguard-frontend-${ENVIRONMENT}" \
          --query 'Stacks[0].Outputs[?OutputKey==`WebsiteURL`].OutputValue' \
          --output text 2>/dev/null || echo "")
        
        echo "api_url=$API_URL" >> $GITHUB_OUTPUT
        echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT

    - name: Run smoke tests
      run: |
        API_URL="${{ steps.get-urls.outputs.api_url }}"
        FRONTEND_URL="${{ steps.get-urls.outputs.frontend_url }}"
        
        echo "ðŸ§ª Running smoke tests for ${{ needs.detect-changes.outputs.environment }} environment..."
        
        # Test API if it was deployed
        if [[ -n "$API_URL" && "$API_URL" != "None" ]]; then
          echo "ðŸ” Testing API health..."
          if curl -f -s "$API_URL/health" > /dev/null; then
            echo "âœ… API health check passed"
          else
            echo "âš ï¸ API health check failed (may still be starting up)"
          fi
        fi
        
        # Test frontend if it was deployed
        if [[ -n "$FRONTEND_URL" && "$FRONTEND_URL" != "None" ]]; then
          echo "ðŸ” Testing frontend availability..."
          if curl -f -s -I "$FRONTEND_URL" > /dev/null; then
            echo "âœ… Frontend availability check passed"
          else
            echo "âš ï¸ Frontend availability check failed (may still be propagating)"
          fi
        fi
        
        echo "ðŸŽ‰ Smoke tests completed"

  # Create deployment summary
  deployment-summary:
    needs: [detect-changes, deploy-backend, deploy-frontend, deploy-frontend-only, smoke-test]
    runs-on: ubuntu-latest
    if: always() && github.event_name != 'pull_request'
    
    steps:
    - name: Create deployment summary
      run: |
        echo "## ðŸš€ Smart Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ needs.detect-changes.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Strategy:** ${{ needs.detect-changes.outputs.deployment_strategy }}" >> $GITHUB_STEP_SUMMARY
        echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸ“Š Change Detection" >> $GITHUB_STEP_SUMMARY
        echo "- **Backend Changed:** ${{ needs.detect-changes.outputs.backend_changed }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Frontend Changed:** ${{ needs.detect-changes.outputs.frontend_changed }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Infrastructure Changed:** ${{ needs.detect-changes.outputs.infrastructure_changed }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸŽ¯ Deployment Results" >> $GITHUB_STEP_SUMMARY
        if [[ "${{ needs.detect-changes.outputs.deployment_strategy }}" == "none" ]]; then
          echo "âœ… **No deployment needed** - Only documentation or non-deployment files changed" >> $GITHUB_STEP_SUMMARY
        else
          echo "**Backend Deployment:** ${{ needs.deploy-backend.result || 'Skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Frontend Deployment:** ${{ needs.deploy-frontend.result || needs.deploy-frontend-only.result || 'Skipped' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Smoke Tests:** ${{ needs.smoke-test.result || 'Skipped' }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ðŸ’° Cost Optimization" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Stable resource names** (no timestamps)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Selective deployment** (only changed components)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Idempotent operations** (safe to re-run)" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… **Proper resource tagging** for cost tracking" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "**Estimated Action Minutes Saved:** 5-10 minutes per deployment" >> $GITHUB_STEP_SUMMARY